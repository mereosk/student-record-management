ΠΑΝΕΠΙΣΤΗΜΙΟ ΑΘΗΝΩΝ
Τμήμα Πληροφορικής και Τηλεπικοινωνιών
1η Εργασία - Τμήμα: Περιττών Αριθμών Μητρώου
Κ22: Λειτουργικά Συστήματα – Χειμερινό Εξάμηνο ΄20
Κωνσταντίνος Μερεός  






Διαδικαστικά
Το πρόγραμμά μου έχει γραφτεί σε γλώσσα c και είναι χωρισμένο σε διάφορους φακέλους. Την κύρια λειτουργία του προγράμματός μου την εκτελεί το πρόγραμμα mngstd.c το οποίο βρίσκεται μέσα στον φάκελο programs. Μαζί με το προηγούμενο βρίσκεται και το Makefile στο οποίο θα αναφερθώ πιο μετά. Στη συνέχεια όλες οι δομές καθώς και όλες οι βοηθητικές συναρτήσεις έχουν χωριστεί στους φακέλους include και modules. Στον include είναι όλες οι αρχικοποιήσεις των διαφόρων δομών και συναρτήσεων καθώς και το common_types.h το οποίο έχει διάφορα typedef για να γίνει πιο ευανάγνωστος ο κώδικάς μου. Ο φάκελος modules περιέχει τις υλοποιήσεις όλων αυτών των δομών. Επιγραμματικά έχω υλοποιήσει μία abstract λίστα με τη βοήθεια διπλά συνδεδεμένης λίστας, ενα map με τη βοήθεια ενός hash table το οποίο λειτουργεί με buckets, με την abstract λίστα έφτιαξα έναν inverted index. Επιπροσθέτως στον φάκελο modules έχω υλοποιήσει κάποιες βοηθητικές συναρτήσεις τις οποίες χρησιμοποιώ σε όλο το πρόγραμμα, αυτές βρίσκονται στο αρχείο func.c. Τέλος μέσα σε έναν φάκελο misc έχω όλα τα input και config αρχεία.


Αρχικοποίηση
Το πρόγραμμα μπορεί να δουλέψει χωρίς κανένα argument στην γραμμή εντολών. Σε αυτήν την περίπτωση η χωρητικότητα του hash table ορίζεται με την μεταβλητή hash_table_size την οποία την όρισα αυθαίρετα να έχει την τιμή 1000. Σε περίπτωση που εισαχθούν πάνω από 1000 στοιχεία μέσα στο map η συμπεριφορά του προγράμματος είναι απροσδιόριστη. το πρόγραμμα μπορεί επίσης να τρέξει με τη μορφή ./exec -i input.txt. Σε αυτήν την περίπτωση η σημαία -i ενημερώνει το πρόγραμμα ότι μέσα στο αρχείο περιέχονται τιμές οι οποίες πρέπει να μπουν στις δομές μου. Πάλι σε αυτήν την περίπτωση η χωρητικότητα του map θα είναι 1000. Η τρίτη περίπτωση argument είναι το ./exec -c config.txt. Αυτό το αρχείο πρέπει να είναι στη μορφή size number, διότι έτσι διαβάζεται ο αριθμός μόνο. Με αυτόν τον αριθμό αρχικοποιείται το hash table. Η τελευταία και πιο σημαντική μορφή είναι ./exec -i input.txt -c config.txt (ή αντίθετα με το -c πρώτο). Σε αυτήν την περίπτωση αφενός διαβάζει δεδομένα και τα εισάγει στις δομές από το input text και αφετέρου παραμετροποιεί και το πρόγραμμά μου δίνοντας ακριβή αριθμό στην αρχικοποίηση του hash table. Τα arguments μπορείτε να τα αλλάξετε στο Makefile δίπλα από τη μεταβλητή ARGS.


Το πρόγραμμα ξεκινάει βλέποντας τι από τα παραπάνω συμβαίνει. Σε κάθε περίπτωση αν του δοθεί κάποιο input file τότε χρησιμοποιεί μία συνάρτηση η οποία διαβάζει κάθε γραμμή αυτού του εγγράφου και τοποθετεί όλες τις τιμές σε μία δομή το Record το οποίο έχει οριστεί στον φάκελο include. Επίσης εισάγει στις δομές τα απαραίτητα δεδομένα. Σε αυτήν την περίπτωση δεν εκτυπώνεται κανένα μήνυμα, σε αντίθεση με την εισαγωγή του interface την οποία θα αναλύσω ενδελεχώς πιο κάτω. Αυτό το έκανα ώστε να μην υπάρχει πρόβλημα με μεγάλα αρχεία σε θέμα χρόνου καθώς και θεωρώ ότι είναι πιο ευανάγνωστο το output. Αν δοθεί στο πρόγραμμα ένα αρχείο config τότε διαβάζει την τιμή και την βάζει ως χωρητικότητα στο map. Οι τιμές αυτές έχουν επιλεχθεί ώστε να μην ξεπερνάω το a = 0.9 το οποίο είναι size/capacity. Αυτό, γιατί αν ξεπεραστεί αυτό το insert γίνεται γραμμικής πολυπλοκότητας.


Δομές
Εδώ παραθέτω τις δομές που έχω υλοποιήσει. Δεν μπαίνω πολύ σε βάθος όσο αφορά τις συναρτήσεις, διότι θα ξεφύγει σε έκταση το έγγραφο. Ελπίζω τα σχόλια που έβαλα στο πρόγραμμα να είναι κατατοπιστικά.
List
Ο κύριος πυλώνας των δομών που υλοποίησα είναι η abstract ADTBList. Η δομή αυτή είναι υλοποιημένη έτσι ώστε να μπορεί να δεχτεί ότι δεδομένο θέλουμε είτε αυτό είναι ένας ακέραιος είτε μία άλλη δομή ακόμα. Είναι υλοποιημένη με διπλά συνδεδεμένες λίστες και το πέρασμά της είναι γραμμικό. Μία ιδιαιτερότητα που την διαχωρίζει από μία απλή λίστα είναι το γεγονός ότι μπορείς να πας από έναν κόμβο και στις δύο κατευθύνσεις. Σε λίγο πιο τεχνικά θέματα, η ADTBList αποτελείται από δύο επιμέρους δομές τη λίστα και τον κόμβο. Ο κόμβος έχει απλά δύο δείκτες στον προηγούμενο και στον επόμενο κόμβο καθώς και την τιμή σε Pointer (void *).
Το κεντρικό struct list έχει μία συνάρτηση καταστροφής την οποία ορίζει ο χρήστης καθώς και το size ώστε να μην χρειάζεται O(n) πολυπλοκότητα να βρεις το μέγεθός της. Επιπροσθέτως έχει έναν δείκτη σε struct list_node στον τελευταίο κόμβο αλλά και έναν κόμβο dummy ώστε ακόμα και μια empty list να έχει έναν κόμβο, αυτό απλοποιεί πολλές λειτουργίες. Πέρα από τα παραπάνω τα σχόλια στις αρχικοποιήσεις των συναρτήσεων στον include φάκελο έχουν λεπτομέρειες για κάθε συνάρτηση. Η κύρια υλοποίηση της λίστας βρίσκεται στα modules και συγκεκριμένα /UsingDoublyLL/ADTBList.c .


Hash table
Στη συνέχεια θα αναφερθώ στην υλοποίηση του hash table. Αποφάσισα να χρησιμοποιήσω τη λογική του hash table για να φτιάξω ένα Map. Όπως προηγουμένως η δομή αυτή είναι abstract δηλαδή ότι δεδομένο και να θέλω να μπει δεν θα δημιουργήσει πρόβλημα. Ακολουθώ την λογική των buckets, δηλαδή η κύρια δομή περιέχει έναν πίνακα ο οποίος έχει δείκτες σε λίστες. Για να βρω που χασάρει το κάθε στοιχείο χρησιμοποιώ μια hash συνάρτηση, στη συγκεκριμένη περίπτωση επειδή το κλειδί του map είναι το id του κάθε μαθητή η hash function παίρνει απλά ένα Pointer (void *) και επιστρέφει την ακέραια τιμή του. Υπάρχουν δύο δομές πάλι, ένας κόμβος ο οποίος έχει ένα κλειδί και μία τιμή και άλλη μια μεγάλη δομή που είναι το map. Αυτή έχει τις συναρτήσεις compare, hash και δύο destroy, οι οποίες τις περνάω μέσω της create και τις αποφασίζει ο χρήστης. Έπειτα κρατάει πόσα στοιχεία έχουν εκχωρηθεί καθώς και τη χωρητικότητα της. Το πιο σημαντικό είναι το List* array το οποίο διαμορφώνει την κύρια λειτουργία. Στην συνάρτηση create πρέπει να δοθεί και η χωρητικότητα του map. Μία ιδιαιτερότητα της δομή είναι ότι έχει δύο insert functions. Η πρώτη map_insert πέρα από την τετριμμένη λειτουργία δεν δέχεται duplicate δεδομένα και επιστρέφει false, έτσι ενημερώνει ότι η εισαγωγή δεν ολοκληρώθηκε. Η δεύτερη, επειδή το value της ουσιαστικά είναι ένας μετρητής που μετράει πόσες φορές έχει εισαχθεί το ίδιο κλειδί, η λειτουργία της είναι να βάζει το κλειδί(το οποίο είναι ίδιο με το παλιό) και να αυξάνει το value κατά 1. Το Map έχει υλοποιηθεί στα modules και συγκεκριμένα /UsingHashTable/ADTMap.c .


Inverted Index
Σε αυτήν τη δομή κύριο ρόλο πάλι έχει η προαναφερθείσα λίστα. Επίσης η δομή αυτή δεν έχει πολλά abstract χαρακτηριστικά, αφού ειδικεύεται πιο πολύ σε κάποια σημεία της (κυρίως στο εσωτερικό επίπεδο που δεν χρησιμοποιείται κάποια συνάρτηση καταστροφής ή σύγκρισης). Συγκεκριμένα έχει δύο δομές μία γενική δομή inverted_index και μία inverted_index_list. Το inverted_index είναι ουσιαστικά μία λίστα με το size όλων των δεδομένων και κάποιες συναρτήσεις καταστροφής και σύγκρισης. Η προηγούμενη mail λίστα περιέχει inverted_index_list το οποίο με τη σειρά του έχει μία δευτερεύουσα λίστα καθώς και έναν Pointer με το value το οποίο, επειδή δεν κράτησα πολύ την abstract λογική το ονόμασα year. Όταν, λοιπόν, εισάγεται ένα δεδομένο στη δομή τότε αυτό πρέπει να μπει στην δευτερεύουσα λίστα. Για να γίνει αυτό ελέγχεται το year του δεδομένου αυτού, αν υπάρχει ήδη τότε ψάχνω το σωστό inverted_index_list και το εισάγω ενώ αν δεν υπάρχει δημιουργώ ένα. Μια λεπτομέρεια, είναι στη remove, εκεί όταν διαγράφεται ένα δεδομένο πρέπει να ελεγχθεί αν μένει άδεια η δευτερεύουσα λίστα. Στο γεγονός αυτό είναι λογικό να διαγράψουμε όλη τη δομή inverted_index_list από τη main list καθώς αυτή η κενή λίστα μπορεί να δημιουργήσει πολλά προβλήματα.


Διεπαφή
Υπάρχει ένα πινακάκι το οποίο δείχνει στον χρήστη τι πρέπει να πληκτρολογήσει. Για όλα τα input υπάρχει μία συνάρτηση η οποία ελέγχει αν ο αριθμός λέξεων στη συμβολοσειρά είναι ο επιθυμητός.


i(nsert)
Διαβάζω και περνάω κάθε τιμή στη δομή Record. Στο τέλος περνάω το record σαν value στο map και στο inverted index και κλειδί στο map χρησιμοποιώ το studentId (τιμή του record). Προσέχω για διπλότυπα και αν υπάρχουν τα μετράω.
l(ook-up)
Ψάχνω στο Map με τη δοθείσα τιμή το record κι αν το βρω το εκτυπώνω. Αν δεν το βρω εκτυπώνω κατάλληλο μήνυμα.
d(elete)
Ψάχνω στο Map με τη δοθείσα τιμή το record και αν το βρω το διαγράφω. Αν δεν το βρω εκτυπώνω κατάλληλο μήνυμα.
n(umber)
Σε αυτήν την περίπτωση χρησιμοποιώ το Inverted Index. Ψάχνω το year που μου δόθηκε και αν υπάρχει επιστρέφω το μέγεθος της δευτερεύουσας λίστας η  οποία περιέχεται μαζί με το year σε μία δομή inverted_index_list.  Αν δεν υπάρχει εκτυπώνω το κατάλληλο μήνυμα.
t(op)
Πάλι χρησιμοποιείται Inverted Index. Αν δεν υπάρχει το year στη δομή εκτυπώνω κατάλληλο μήνυμα. Αν υπάρχει βρίσκω τη δομή στην οποία περιέχεται η λίστα με τους μαθητές του year. Θέλω τους καλύτερους, οπότε με επαναλήψεις βρισκω το max του gpa των μαθητών και αφού το βρω διαγράφω το record απο τη λίστα προσωρινά. Όταν ολοκληρώσω και τις num αναζητήσεις εκτυπώνω τους μαθητές και επαναφέρω στην προηγούμενη κατάσταση τη λίστα.
a(verage)
Αν υπάρχουν μαθητές τη συγκεκριμένη χρονιά στο Inverted Index, τότε βρίσκω τον μέσο όρο τους διατρέχοντας τη δευτερεύουσα λίστα. Αν δεν υπάρχουν εκτυπώνω το κατάλληλο μήνυμα.
m(inimum)
Είναι ακριβώς αντίθετη λειτουργία με το t(op). Η μόνη διαφορά είναι αντί να βρίσκω τους καλύτερους (εδώ χειρότερους μαθητές) βρίσκω πόσοι μαθητές έχουν το ίδιο χειρότερο μέσο όρο πάλι με τη λογική της διαγραφής από τη λίστα όπως και πριν.
c(ount)
Εκτυπώνω πόσους μαθητές έχει η κάθε χρονιά διατρέχοντας τη main λίστα και εκτυπώνοντας το μέγεθος της κάθε δευτερεύουσας λίστας. Αν δεν υπάρχει κανένας μαθητής εκτυπώνω κατάλληλο μήνυμα.
p(ostal code)
Εδώ χρησιμοποιώ το Map. Συγκεκριμένα διατρέχω το βασικό μου map και περνάω όλες τις τιμές σε ένα άλλο του οποίου κλειδιού βάζω το zip code του κάθε record. Κάθε φορά που έχω duplicate αυξάνω κατά 1 το value. Έτσι μπορώ με τη βοήθεια διαγραφών όπως ακριβώς και στο t(op), αλλά εδώ από map και όχι από λίστα, μπορώ να βρω το rank διασημότερο zip code. Τέλος διατρέχω το καινούριο map για να εκτυπώσω και ισοβαθμίες.
e(xit)
Βγαίνω από την επανάληψη διαγράφοντας όλες τις θέσεις μνήμης.




Ευχαριστώ πολύ για το χρόνο και την υπομονή σας.
